## Темы задач на самостоятельную работу

Ниже нарочито неформально даны описания мини-языков, интерпретатор которых вам предстоит реализовать на OCaml, чтобы получить допуск к финальной аттестации (экзамену).

Я рассчитываю, что сами разделите темы с помощью Excel-подобной таблички.

Темы задач выдаются на двоих, т.е. почти у всех самостоятельная работа будет разная.
Если вера в собственные силы крайне мала, есть **одна отдельная тема для всех** тех, **кому достаточно** получить после экзамена максимальную оценку **E**. Потом можно передумать и переписаться на другую незанятую задачу (в том числе и на максимум E).

В том году темы выдавались на одного, потому хвостисты страдают.

Во всех работах, где надо писать инерпретатор типизированного языка, надо писать тайпчекер тоже. Скорее всего он будет запускаться до интерпретатора. Проверки типов, которые можно сделать на фазе типизации, нужно делать на фазе типизации, их нельзя делать в интерпретаторе.


### Тема для допуска на E

Задача выдается, если вас устраивает итоговая оценка не выше E. Данная тема выдается неограниченному кругу студентов. Я в свою очередь не буду смотреть код и запускать линтер --- проверяться  будет только прохождение тестов.

Реализовать для языка miniML:
* синтаксический анализатор (парсер),
  * Он должен работать шустро, а не парсить объявления факториала 10 секунд.
* type checker
* интерпретатор.

Должны обрабатываться ошибки процессе парсинга/типизации/интерпретации (ДЗ не должно крешиться).

### Описание MiniML

В язык включаются:
* Целые числа, булевы значения и сравнения чисел и прочая арифметика
  * Идентификаторы должны быть как в OCaml, запрещено резервировать какие-то имена, чтобы их порождать по ходу дела.
  * К идентификатором разрешено приписывать типы явно
* Рекурсивные функции (в компиляторе, объявленные глобально называются [structure_item](https://github.com/ocaml/ocaml/blob/5.2.0/parsing/parsetree.mli#L1029)).
  * First-class функции, с  частичным примерением и взаимной рекурсией.
  * Каррирования и замыкания
  * Вложенные let-определения
  * Не должно быть никакого ограничения сверху на количество аргументов у функций.
* Стандартные типы данных: bool, int и n-ки (англ. tuples), списки и option.
  * Полноценные алгебраические типы не надо.
* Стандартные функции, чтобы что-нибудь напечатать по ходу интепретации (печать строки, печать числа и т.п.).
  * Во всех задачах про OCaml, аргумент ~~анонимной~~ функции является так называемым паттерном (англ. pattern).
    Выражения там разрешать писать нельзя!
  * Захардкаживать стандартные функции (а ля print_int) в отдельные виды узлов AST нельзя.

Для этой задачи выбирайте имя директории в виде ``[E]Фамилии'' латиницей.

### Основные домашки

1. OCaml + ADT <details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * алгебраические типы как основной способ проектирования типов; учтите, что
     * в OCaml и Haskell типы int и float -- примитивные (встроенные)
     * тип списков алгебраический и там, и там; в AST не должно быть, что списки отдельно, а алгебраические значения отдельно
     * в OCaml тип bool примитивный, а в Haskell -- алгебраический
   * разумеется, объявления типов, паттерн-мэтчинг и типизация
   * присваивание не надо
   * исключения не надо
   </details>
1. OCaml + Extensible variant types <details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * алгебраические типы заменены на extensible variants
   </details>
1. OCaml + Recursive values <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * [Recursive definitions of values](https://v2.ocaml.org/manual/letrecvalues.html). В простенькие бесконечные списки должно быть можно заглядывать.
     * Плохой синтаксис должен выдавать ошибку типизации: this expression is not allowe on RHS of let rec
   </details>
1. OCaml + полиморфные вариантые типы<details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * [Глава про полиморфные варианты в мануале OCaml](https://v2.ocaml.org/manual/polyvariant.html)
   * Объявления типов можно не делать
   * Стандартные типы (пары, списки, option) можно делать, а можно не делать, выразив через полиморфные варианты
   </details>
1. OCaml + bidirectional records <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * поддержать синтаксис приписывания (англ. ascription) типов переменным
   * records (a.k.a. записи, структуры) c полями из базовых типов или других записей.
     * в случае перекрытия имен интерпретатор должен учесть приписанные типы. В примере ниже без аннотаций типов результат вывода будет другой
      ```ocaml
      type t = { aa: int; bb: bool }
      type s = { aa: float; cc: int }
      let f (x : t) = x.aa
      let g (x : s) = x.aa
      ```
    </details>
1. OCaml + [labelled tuples](https://github.com/ocaml/ocaml/pull/13498)
1. F# + active patterns <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * возможность описывать [активные паттерны](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns), которые выглядят как алгебраические конструкторы
      ```
      let (|Even|Odd|) input = if input % 2 = 0 then Even else Odd
      ```
    * Возможность использования активных паттернов в сопоставлении с образцом
      ```
      let TestNumber = function
      | Even -> printf "%d is even\n" input
      | Odd -> printf "%d is odd\n" input
      ```
    </details>
1. F# + Units of Measure <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * Вещественные числа (обосновано следующим пунктом)
   * Возможность объявлять и использовать [Units of Measure](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure)
   </details>
1. Haskell + стандартные типы данных + ленивость<details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * С ленивостью надо будет продемонстрировать работоспособность
      * Лямбда-исчисления с call-by-name
      * ленивых списков и операция над ними (в том числе, фибоначчи, решето Эратосфена и т.п.)
      * прочие ленивые задачи (например, за один проход заменить все числа в дереве на их минимум и вернуть новое дерево)
    </details>
1. Haskell + [Pattern Synonyms](https://gitlab.haskell.org/ghc/ghc/-/wikis/pattern-synonyms) + [View Patterns](https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns)<details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * Два расширения Haskell на тему сопоставления с образцом.
   * Это очень похоже на тему про F# + Active patterns.
   * Хоть это и хаскель, для упрощения жизни, я не планирую проверять ленивость стратегии. Можете делать вид, что это скорее PureScript
    </details>
1. Purescript + простые классы типов<details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * Синтаксис не как в OCaml, а скорее как в Haskell, вычисления строги
   * Простая поддержка классов типов --- средства для overloading.
   </details>
1. OCaml + [ООП](https://v2.ocaml.org/manual/objectexamples.html) <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E, кроме n-ок.
   * в OCaml есть интересные объекты и их типизация, нужно поддержать объекты+методы+поля.
   * (может быть классы и наследование тоже надо будет, но пока не уверен)
   * как тесты предлагаю реализовать некоторые структуры данных как камлёвые объекты и посмотреть, что будет
   </details>
1. OCaml + printf <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * Поддержка типов char, string и операций с ними
   * Поддержка в компиляторе функции форматированой печати (по аналогии с камлёвым модулем Printf/Format).
     * printf, sprintf, ksprintf, конкатенация форматированных строк
     * Разумеется, всё должно быть type safe.
   </details>
1. OCaml, именованые и опциональные аргументы <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * Захардкоженный тип option
   * Именованные и опциональные аргументы. Функции должны типизироваться и исполняться как в настоящем OCaml.
   </details>
1. OCaml + weak type variables <details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * https://ocamlverse.net/content/weak_type_variables.html. Присваивание неоходимо, так как без него тема бессодержательна.
   </details>
1. SML + equality types + value restriction <details><summary>Подробнее</summary>
   + Почти предыдущая задача, но проще
   + Немножко другой парсер, потому что SML немножко отличается
   + Еquality types:
      * в типах функций появляются типовые переменные с двумя апострофами, что означает, что туда можно подставлять только типы, на которых работает функция проверки на равенство (функции и вещественные числа нельзя сравнивать)
   + Value restiction
     * Заставляет выводить менее полиморфные типы, потому что присваивание может нарушать типовую безопасность
     * https://users.cs.fiu.edu/~smithg/cop4555/valrestr.html
    </details>

1. Scala + By-name Parameters <details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * Другой парсер (!)
   * [Параметры функций](https://docs.scala-lang.org/tour/by-name-parameters.html), которые не Call-by-Value (как в OCaml/Scala), а call-by-name (как в Haskell)
   </details>
1. Scheme + call/cc  <details><summary>Подробнее</summary>
   * относительно легко гуглящаяся особенность Scheme
   * call/cc
   * целые числа, рекурсия, списки, печать на консоль
   * функции обычные и анонимные, замыкания и рекурсия
   * присваивание не надо
   * quote/unquote
   * парсер очень простой
   * никаких статических типов, разумеется, нет
   </details>
1. Scheme + delim/cc <details><summary>Подробнее</summary>
   * почти как предыдущая задача, только понятней
   * Кратко про delim/cc
      + есть две новые конструкции в языке: `reset (fun () -> M)` и `shift (fun k -> M)`
      + Пример: `reset (fun () -> 2 + 2 * shift (fun k -> k 20))`
         + Наличие одинокого `reset` не влияет на вычисление
         + Когда исполнение доходит до `shift`, то вместо аргумета подставляется функция, которая "зажата" между этим `shift` и ближайшим `reset`, В данном случае это `fun y -> 2 + 2 * y`
         + таким образом, выражение выше вычисляется в 42
   </details>
1. Ассемблер RISC-V 64 <details><summary>Подробнее</summary>
    * Очень простой язык и для парсинга, не особо сложный для интерпретации.
    * Язык должен быть настоящим ассемблером, т.е. входные программы должны компилироваться соответствующим (кросс)компилятором и выдавать ответ как в интерпретаторе. Сделайте cram тесты, демонстрирующие это.
    * Нужно поддержать некоторые системные вызовы Linux для отладки программ, на подобие выхода и печати в stdout.
    * Так как язык простой, нужны расширения Bitmanip и RVV, в мере, достаточной для интересных тестов.
    * Опыты прошлых лет показывает, что написание AST в лоб оставляет большое пространство для плохих программ, представимых в AST. Например, 64битные команды никак не должны принимать 32битные операнды-регистры как аргументы. Потребуется обмазаться фантомными-типами и/или GADT, чтобы не нужно было писать гавнокод. Буду следить!
    </details>
1. Go с горутинами  <details><summary>Подробнее</summary>
   * Стандартные типы данных (int, bool, string)
   * Циклы
   * Условный оператор (if)
   * Массивы
   * Функции (обычные, рекурсивные, замыкания (в том числе с поддержкой присваивания))
   * Каналы (достать, положить, закрыть)
   * Горутины (переключение по ожиданию данных из канала)
   * Замечания:
        * используется урезанная версия Go 1.17
        * в string нету доступа по индексу (т.к. нету символьного типа)
        * ключевые слова: break func defer go chan if else continue for return var
        * предопределенные идентификаторы: bool int string true false nil make close len panic print println recover
   </details>

### Посложнее

1. OCaml с типизированными эффектами <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * C эффектами: присваивание, печать на консоль и try/catch/raise для пары захардкоженных в язык исключений. Из-за присваивания -- два человека
   * С системой типов в описанном выше смысле.
   * https://www.janestreet.com/tech-talks/effective-programming
   * Идея заключается в том, что теперь мы будем перечислять в типе функции-стрелке эффекты, которые совершает функция
      * Обычная стрелка `->` делает что угодно
      * Длинная стрелка `-->` (или `-[]->`) -- это чистая функция: ни присваиваний, ни ввода-вывода. Ничего не делает такого.
      * Над стрелкой можно перечислять, что она делает:
          * `-[IO]->` делает ввод-вывод
          * `-[exc Not_found]->` кидает исключение `Not_found`
          * `-['a]->` совершает какой-то эффект, но он не указан (полиморфизм)
      * Пример:

      ```ocaml
        val id : 'a --> 'a
        val print_int: int -[IO]-> unit

        let map : ('a -['e]-> 'b) --> 'a list -['e]-> 'b list = fun f xs ->
          match xs with
          | [] -> []
          | x::xs -> (f x) :: (map f xs)

        let _ : 'a list --> 'b list = map id
        let _ : int list -[IO]-> int list =
          map (fun n -> print_int n; n+1)
      ```

        Фунция `id` чистая, поэтому над стрелочкой ничего не написано.

        Функция `print_int` совершает ввод-вывод, что указано в типе.

        `List.map` полиморфна (как обычно) по типу элементу списка, но также полиморфная по типу эффекта переданной функции, что указано в стрелке, которая выдает результат. Первая стреклка в типе `map` чистая, так как при передаче аргументов ничего не вычисляется и эффектов не совершается. В `map id` не совешается эффектов, поэтому типовая переменная `'e` сунифицировалась с отсутсвием эффектов. Во втором примере из-за того, что переданная функция совершает ввод-вывод, система типов догадывается, что и вычисление `map` совершает ввод-вывод.

        Вы уже видели приписывание эффектов к функциям, а именно, приписывание бросаемых исключений в языке Java. Но так как там не было полиморфизма по этим "эффектам", то люди ненавидели эту штуку и поэтому, на сколько я знаю, в идеалогических наследниках Java этого нет.
   </details>
1. OCaml + GADT <details><summary>Подробнее</summary>
    * Всё, что есть в задаче OCaml+ADT
    * OCaml где алгебраические типы заменены на обобщенные (generalized) алгебраические типы
    * Интерпретатор точно будет такой же, как в задаче про обычные алгебраические типы
    * Вывод/проверка типов (сильно) сложнее, чем для обычных алгебраических, поэтому два человека
      * Нужно поддержать явные аннотации типов, потому что автоматический вывод типов не могёт
      * Типовые переменные могут убегать из области видимости и т.д.
    * [Умная сслыка, описывающая что примерно вас ждет](https://ocaml.org/releases/4.12/manual/gadts.html)
    * Если будут работать гетерогенные списки и равенство по Лейбинцу, то можно и С поставить без экзамено обоим
    </details>
1. OCaml + effects  <details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * Cупер-модное в наши дни движение в мире ФП
   * По сути, это исключения, но в момент обработки которых у нас есть функция, которой можно был передать значение, которое должно было бы быть вместо бросания исключения, и продолжить исполнение с места бросания исключения.
   * Туториал в контексте OCaml https://github.com/ocamllabs/ocaml-effects-tutorial
   </details>
<!--
1. OCaml+ non prenex polymorphism?
1. SML + flex records <details><summary>Подробнее</summary>
   * Всё, что есть в теме для  E
   * Парсер, соответсвующий языку Standard ML (поиграйтесь либо с SML/NJ или Mlton, оба есть в репах Ubuntu)
   * Записи как в языке [SML](http://adam.chlipala.net/mlcomp)
   * Anonymous record types
   * Специальный синтаксис для доступа к n-кам (`#1 ..., #2`)
   </details>
1. Ассемблер x86_64  <details><summary>Подробнее</summary>
    * Очень простой язык и для парсинга, не такой простой для реализации интерпретатора.
    * Язык должен быть настоящим ассемблером, т. е. входные программы должны компилироваться соответствующим компилятором (nasm) и выдавать ответ как в интерпретаторе. Сделайте cram тесты, демонстрирующие это.
    * Примеры в первую очередь берите из первой части книжки И. Жиркова "Low-level programming". Там должен быть helloworld, который требует syscall и память.
    * Чтобы задача не была чересчур простой, хочу также в ассемблере SIMD операции и тесты к ним (перемножение вектора/матрицы на вектор/матрицу)
    * Опыты прошлых лет показывает, что написание AST в лоб оставляет большое пространство для плохих программ, представимых в AST. Например, 64битные команды никак не должны принимать 32битные операнды-регистры как аргументы. Потребуется обмазаться фантомными-типами и/или GADT, чтобы не нужно было писать гавнокод. Буду следить!
    </details>
1. Refal 5
   * одскульный отечественный язык программирования, где последовательности можно мэтчить не только с начала, но и с конца
   * [здесь](http://refal.botik.ru/book/html/examples/examples.cgi?ex_index=0), есть 22 примера простых программ на рефал-5
   * а [здесь](http://refal.botik.ru/scp_demo/) есть програмки посложнее
1. Pascal c алгебраическими типами
   * Числа, строки и операции с ними. Функции обычные и вложенные, с рекурсией. Вроде как по сравнению с miniML тут не будет вывода типов, только проверка типов. Присваивание не надо.
   * алгебраические типы данных [variant records](https://www.bestprog.net/en/2016/10/10/records/#q12) (пункт 12).
1. Cи <details><summary>Подробнее</summary>
   * Целые числа разного размера (например, int32_t и int8_t)
   * char
   * Cтандартные конструкции: циклы, ветвления, прочие
   * Указатели и арифметика указателей, malloc / free
   * Продемонстрировать стандартные примеры программ на указатели
      * Короткий memcpy и что с ним может пойти не так
      * Реинтерпретировать кусок памяти с массивом int32_t как в 4 раза большее количество чисел int8_t
   * Функции и рекурсия: факториал, фибоначчи, и т.п.
   * Объявления пользовательских структур не надо.
   </details>
1. Lua -- примитивный язык без статических типов <details><summary>Подробнее</summary>
   * Вещественные числа, строки
   * Функции и функции высшего порядка
   * Стандартные конструкции: ветвления, цикл и т.п.
   * Присваивание и хитрые ассоциативные массивы с двойной индексацией, специфичные для Lua
   </details>
1. Javascript (2 человека) <details><summary>Подробнее</summary>
   * Объекты, числа, строки, массивы (т.е. присваивание надо)
   * Функции обычные и анонимные, замыкания, рекурсия
   * Типичное для Javascript прототипное наследование
   * Стрёмные штуки из [WAT talk](https://www.destroyallsoftware.com/talks/wat) и [отсюда](https://github.com/denysdovhan/wtfjs/blob/master/README.md#table-of-contents). Их будет много (постепенно добавлю)
    </details>
1. Моделирование параллельного исполнения <details><summary>Подробнее</summary>
   За описание благодарите старшего студента.
   * Ast
       Программа состоит из N параллельных участков. В них бывает арифметика, присваивание, thread-local registers (отдельный для каждого потока набор регистров, например EAX, EBX или r1, r2), shared variables (переменные в которые могут писать и из которых могут читать сразу несколько потоков), ветвления и барьеры чтения/записи.
   * Parser
        Код потока записывается в столбик, код разных потоков разделен с помощью значка |||. Потоки исполняются параллельно. Если нет идей как такое парсить, то попробуйте следующий способ. Научитесь парсить один конкретный поток по его индексу (нулевой, первый, …, N-1й), потом используя эту функцию распарсите все потоки по очереди и получите список распаршеных потоков.
        Пример кода на этом языке:
         ```
         x <-1   ||| y<-1
         smp_mb  ||| smp_mb
         r1 <-y  ||| r2<-x
         ```

        Здесь x,y это shared переменные. r1,r2 – локальные для потока регистры. smp_mb – барьер памяти. В этом примере 2 параллельных потока, в каждом потоке 3 инструкции.
   * **Интерпретатор**
      Не стоит пугаться, на самом деле вы будете исполнять по одной инструкции за раз чередуя потоки из которых эта инструкция берётся. Модель же памяти будет влиять на операции чтения и записи: эффекты этих операций могут проявляться не в те моменты времени, как вам подсказывает интуиция, из-за этого возникают интересные поведения.
      Отмечу, что интерпретатор должен осуществить всевозможные исполнения переданной ему на вход программы, с этим поможет монада List (или другая монада для недетерминизма).
   * Описание моделей памяти:
      * Sequential Consistency – простейшая модель, выбираете произвольный поток и исполняете в нем одну инструкцию. Повторяете пока есть неисполненные инструкции. Барьеры памяти в этой модели не оказывают эффекта на исполнение программы.
      * TSO – модель памяти процессоров x86. Здесь возможны интересные поведения. Если в примере выше изначально в переменных x и y хранятся значения ноль, а также из кода будут удалены инструкции барьеров памяти (smp_mb), то возможны поведения, в которых после исполнения будет x == 0 и y == 0. При наличии барьеров памяти после исполнения хотя бы одна переменная всегда будет иметь значение один. Вообще этот код называется store buffering test о нём и не только о нём можно прочесть в статье a better x86 memory model.
   * **Полезные материалы:**
      * [Открытая лекция «weak memory models»](https://youtu.be/P4AnGeVFbzo?list=PLlb7e2G7aSpRgsZVTYYbpqiFrIcIpf8kp) от Антона Подкопаева. В CSC тоже были лекции на эту тему: [раз](https://www.youtube.com/watch?v=VcesAbhnGKU&list=PLlb7e2G7aSpQCPeKTcVBHJns_JOxrc_fT&index=11) и    [два](https://www.youtube.com/watch?v=kg0ZVbBdsMM&list=PLlb7e2G7aSpQCPeKTcVBHJns_JOxrc_fT&index=12).
      * К двум лекциям от CSC необходимо добавить статью Memory Barriers: a Hardware View for Software Hackers ([http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf](http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf))
      * Статья расскажет о том, что такое store buffer(write buffer) и как работают барьеры памяти. [A better x86 memory model: x86-TSO (extended version)](https://www.cl.cam.ac.uk/~pes20/weakmemory/x86tso-paper.pdf). В ней можно найти тесты (litmus tests) для модели x86 и проверить свой интерпретатор
      * [СТАТЬЯ, КОТОРАЯ МЕНЯЕТ ВСЁ!](https://habr.com/ru/company/JetBrains-education/blog/523298/) После прочтения этой статьи в конце 3й недели работы над домашкой. Я за 2 часа удалил 2/3 своего кода и получил работающие модели. Поэтому я уверен, что она может сильно помочь, после того, как всё предыдущее будет изучено и что-то будет написано.
   </details>
1. OCaml + effects (2 человека)<details><summary>Подробнее</summary>
   * Всё, что есть в теме для E
   * Cупер-модное в наши дни движение в мире ФП
   * По сути, это исключения, но в момент обработки которых у нас есть функция, которой можно был передать значение, которое должно было бы быть вместо бросания исключения, и продолжить исполнение с места бросания исключения.
   * Туториал в контексте OCaml https://github.com/ocamllabs/ocaml-effects-tutorial
   * два человека только потому, что хочу чтобы задачу кто-то взял. А так это **очень** сильно напоминает задачи про delim/cc
   </details>
1. Объектно-ориентированый C# c классами и интерфейсами <details><summary>Подробнее</summary>
   * Наследование классов и интерфейсов, без generics.
   * public/private/protected и override.
   * Стандартные конструкции языка + приведение типов объектов.
   * Целые числа, строки, стандартные функции работы с ними; массивы и лямбды не надо.
   * Функции для печатанья значений переменных в языке.
   * Тайпчекер на случай, чтобы отфильтровывать бредовые программы.
   * [new методы](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-modifier)
        * Я слышал, что при их использовании вместе с интерфейсами, там возникает какая-то нетривиальная семантика. Надо будет разобраться. [Вот](https://gist.github.com/Kakadu/331354abae0269e6495bbb0af416853c) пример.
   </details>
1.  C# с исключениями <details><summary>Подробнее</summary>
    * С#
      * Int, string, bool (без array, double)
      * тип `var` по желанию (если не считаете C# *** языком)
    * один класс в котором Main, другие методы и поля. Рекурсия, стандартные конструкции, присваивание.
      * Анонимные лямбды не надо.
      * `ovarride/virtual` не надо (бессмысленно)
    * Без вложенных классов и методов
    * Синтаксис задания исключений. Наследование рудиментарное, только для исключений на 2 уровня глубины
    * Try/Catch/finally, фильтры исключений
      * API для открытия и записи в файл, чтобы можно было проверить, что в finally файл действительно закрывается.
    </details>
1. С# с [мультиметодами](https://en.wikipedia.org/wiki/Multiple_dispatch#C#) <details><summary>Подробнее</summary>
    * По сслыке есть пример из Вики, который показывает их в действии.
    * Поддержать нужно в языке как минимум всё то, что нужно для этого примера
    * присваивание надо, функции как first class citizens -- нет.
    </details>
1. Python <details><summary>Подробнее</summary>
   * Cтандартные конструкции: циклы, ветвления, прочие
   * Стандартные типы: числа, строки, списки
   * Функции, анонимные функции, рекурсия и т.п.
   * Интерполяция строк
   * Классы и методы. [Динамическое дополнение методов](https://block.arch.ethz.ch/blog/2016/07/adding-methods-to-python-classes)
   * Учитывать отступы и отсутствие отступов тоже надо
      ```python
      >>> {
      ...     "this": True,
      ...     "that": False,
      ...     "them": [1, 2,
      ... 3, 4, 5,
      ... 6, 7, 8,
      ... 9, 10, 11, 23]
      ... }
      {'this': True, 'that': False, 'them': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 23]}
      ```
   </details>
1. Ruby (все фичи, что есть в Питоне, но Руби)
1. [Menhir](http://gallium.inria.fr/~fpottier/menhir/manual.pdf) + рекурсивный спуск <details><summary>Подробнее</summary>
   * Такой своеобразный DSL для написания парсеров. По умолчанию он парсит LR-способом (вам не обязательно знать, что это такое)
   * без action кода, ассоциативность и приоритеты нужны
   * устранение левой рекурсии
   </details>
1. Go <details><summary>Подробнее</summary>
    * Стандартные типы данных (int, bool, string, char)
    * Функции (обычные, рекурсивные, first-class, замыкания (в том  числе с поддержкой присваивания))
    * Циклы, условный оператор (if)
    * Массивы и присваивание можно не делать
    * Прочее
      * ключевые слова: break func if else continue for return var
      * предопределенные идентификаторы: bool int string true false nil len panic print println recover
    </details>
1. Prolog/Datalog [Solving murder with prolog](https://xmonader.github.io/prolog/2018/12/21/solving-murder-prolog.html)
1. [Cypher](https://neo4j.com/developer/cypher) <details><summary>Подробнее</summary>
    * мини-язык для доступа к графовым базам данных
    * простой парсер, простой интепретатор, который исполняет запросы на конкретных графах
    * Пример возьмите [отсюда](https://neo4j.com/docs/cypher-manual/current/clauses/match/) и [отсюда](https://neo4j.com/docs/cypher-manual/5/clauses/where/), их там много
    * Использовать свой тип данных для представления графов  **запрещено**. Возьмите какую-нибудь библиотеку.
    </details>
1. Производительный SQL <details><summary>Подробнее</summary>
    * Минимальный язык запросов к базам данных: SELECT, JOIN WHERE и может что-то ещё
    * Интерпретатор запросов на этом языке
    * Эти запросы должны исполняться на больших данных, автогенеренных с помощью https://github.com/NetApp/SQL_Storage_Benchmark. Постарайтесь не складывать большие файлы в Git, а придумать, чтобы они докачивались при билде.
    * Большие входы должны заставить интерпретатор исполняться запросы эффективно, а не как попало.
    </details>
1. [LLVM IR](https://llvm.org/docs/LangRef.html) <details><summary>Подробнее</summary>
    * Типы:
        * int'ы разной битности (i1 - int из одного бита = bool)
        * half, float, double
        * указатели
        * вектора, массивы, структуры
        * функции
        * токены, метки
    * [Весь набор инструкций](https://llvm.org/docs/LangRef.html#instruction-reference)
    * [High level structure](https://llvm.org/docs/LangRef.html#high-level-structure) реализовывать не нужно, но нужно уметь их отбрасывать, чтобы можно было запускать программы включающие их
   </details>
1. TODO MoonBit
2. TODO purescript
1. OCaml + скомпилированные алгебраические типы <details><summary>Подробнее</summary>
   * (задача может показать объёмной, поэтому разрешаю сдавать в одной кодовой базе в месте с задаче про OCaml + ADT)
   * Прочитать как окамлёвые алгебаические [типы представляются в памяти](https://dev.realworldocaml.org/runtime-memory-layout.html), разобраться как устроены "блоки" и unboxed immediate values
   * Написать парсер (параметризовать уже существующий из другой задачи) который понимает функции для конструирования/заглядывания в блоки
   * Интерпретатор
   * Алгоритм преобразования программ с алгебраиками и сопоставлением с образцом в низкоуровневое представление.
   * Преобразования программ из задачи про ADT, в низкоуровневое представление этой задачи. (По сути надо избавляться от алгебраических значений и сопоставления с образцом. Можно посмотреть алгоритм с матрицами [отсюда](https://www.researchgate.net/publication/2840783_Optimizing_Pattern_Matching) )
   </details>

### Гробики

40. [OchaCaml](http://pllab.is.ocha.ac.jp/~asai/OchaCaml) (Caml Light + delim/cc) (2 человека, т.к. напоминает гроб) <details><summary>Подробнее</summary>
    * стандартные типы (числа, списки),
    * функции обычные и анонимные, замыкания и рекурсия
    * конструкции для отладочной печати
    * delim/сс
    * полиморфные типы для всего этого
      * типизация там необычная, надо по одной ссылке долистать до описания того, как это типизировать; по другой ссылке долистать до способов написания интерпретатора/компиляции
    * По сути эта задача и две предыдущие про */сс -- суть одно и то же
    </details>
1.


1. OCaml + IO monad <details><summary>Подробнее</summary>
   * mini-ML с функциями обычными и анонимными, замыканиями и рекурсией
   * Поддержка минимального интерфейса для ввода-вывода и присваивания
      * Монада 'a io в stdlib
      * `print_int : string -> unit io`
      * `read_int: unit -> string io`
      * `create_mutable: unit -> 'a ref io`
      * `assgn: 'a -> 'a ref -> unit io`
      * `(>>=): 'a io -> ('a -> 'b io) -> 'b io`
      * Если вместо `(>>=)` покажется проще поддержать `let*`, то ОК
        </details>
1. C++ и наследование <details><summary>Подробнее</summary>
   * Объявления функций, приваивание, рекурсия, стандартные типы, что-то для печати на консоль.
   * Объекты, поля, методы
   * Анонимные функции можно не делать
   * Наследование: public, private, protected, virtual
      * diamond problem1.
1. F# (Быков на F#)

1. Стрёмное подмножество c# <details><summary>Дмитрий Кузнецов</summary>
   * Async/await
   * Стрёмный LINQ синтаксис: `select ... from ... where ...`
   * лямбды с присваиваниями и замыканиями
   * Пользовательские классы можно не делать, один класс Program c кучей статических методов пойдет.
   * Стандартные типы данных, массивы
      * продемонстрировать на массивах `ArrayTypeMismatchException` </details>
1. OCaml + модули (2 человека) <details><summary>Подробнее</summary>
    * MiniML c базовыми типами, (целые числа, строки) и стандартными алгебраическими (option, list)
    * Объявления типов-синонимов (type abbreviations, typedef)
          `type ('a, 'b) my_typ = 'a * ('b, 'b) list`
          * пользовательские алгебраические типы не надо
    * Объявления модулей и типов модулей
        * Многофайловость не надо
        * `let module X = ... in ` не надо
        * Функторы не надо (может потом про них отдельную задаче сделаю)
    * Передача модулей как first-class values в функции
      Пример:

     ```ocaml
     # module type SHOW = sig type t  val show : t -> string end;;
     module type SHOW = sig type t val show : t -> string end
     # module ShowInt: SHOW with type t = int  = struct type t = int let show = string_of_int end;;
     module ShowInt : sig type t = int val show : t -> string end
     # let show (type a) x (module S: SHOW with type t = a) = S.show x;;
     val show : 'a -> (module SHOW with type t = 'a) -> string = <fun>
     # show 42 (module ShowInt);;
     - : string = "42"
     ```
     </details>



1. Haskell + custom operators
    * MiniML c поддержкой пользовательских операций, назначением им приоритетов и ассоциативности.

   ```haskell
   infixl 6 -
   infixr 5 :
   infix  4 ==
   ```

    * Халява. Кастомные операции в интерпретаторе, а в остальном только усложнение парсера.
    * Если сложно поддерживать синтаксис хаскеля, то можно сделать синтаксис камла с расширением операциями задания ассоциативности/приоритетов.
1. miniML с компиляцией в .NET (2 человека, только потому что выглядит страшно) <details><summary>Подробнее</summary>
   * Взять miniML, по нему сделать MSIL, натравить компилятор из MSIL в .NET, и оно запускается!
   * Интерпретатор писать не надо, у нас .NET вместо интерпретатора будет.
   * Страшно может быть только потому, что внутреннее представлением программ на .NET пугливому студенту покажется страшным
   * По факту, надо взять miniML; сделать lambda-lifting, чтобы внутри функций не создавались замыкания; вытащить внутри объявленные функции вверх; отобразить полученные фукнции в статические методы один к одному
   * Другой независимой задачей будет поддержка арифметических выражений, путём отображения в стековые команды .NET
   * Ну, а когда это уже будет готово, надо будет поддержать пары, тип option, и остальное по мелочи.
   </details>
1.


1. Котлин, ООП и flow-sensitive typing
   * Стандартные типы данных, функции/методы, присваивание
   * функции/методы обычные и анонимные, замыкания и рекурсия
   * ООП, наследование, вызов методов, изменение полей
   * Flow-sensitive typing: вывод того, может ли значение быть null или нет
      * Важный пример [отсюда](https://counterexamples.org/under-construction.html) должен работать
   * Давать на двоих не хочу, так как про всё это вам должны были рассказывать.

1. Ruby
    * Известный язык программирования, по типу Питона
    * Стандартные конструкции, присваивание,
    * Рекурсивные и анонимные функции, замыкания
    * Объекты
    * Статической типизации там нет, потому и не надо
    * `method_missing` -- отличительная штука Ruby, где можно сказать, что делать, если метода нет
      * с помощью обработки отсутсвующего метода предлагаю сделать примеры про реализацию тестирования кода в стиле [rspec](https://github.com/rspec/rspec-core)
    * Прикольные штуки из [WAT talk](https://www.destroyallsoftware.com/talks/wat)

1. Bash <details><summary>Подробнее</summary>
   * Надо будет сделать основную штуку, что отличает bash от всего остального -- вызов сторонних исполняемых файлов по ходу дела
      * Чтобы Ctrl-C их сторонних файлов возвращался обратно в bash
      * Чтобы вызов через пайпы правильно соединял различные stdin и stdout
   * Кавычки одинарные и двойные
      * Escape character сделайте для перносов строк и экранирования кавычек. Всякие `\t` не надо.
      * Нужны ли ANSI-C Quoting и Locale-Specific Translation?
   * Комментарии не надо
   * Команды
      * Простые команды
      * Пайплайны
        * поддержка [time [-p]] и [!] *не нужна*
      * Списки команд `&&` нужны
      * compound
        * until, while (один из)
        * for два варианта
        * if, case
          * select не нужен
        * `((...))`
        * `[[...]]`
          * Влечет за собой поддержку Conditional Expressions
            * Только С locale
        * без [Grouping Commands](https://www.gnu.org/software/bash/manual/bash.html#Command-Grouping)
        * без `coproc`
   * Функции (два варианта синтаксиса)
      * С рекурсией.
   * Параметры
     * Переменные, разумеется. На `+=` можно забить
     * Нужна ли поддержка positional parameters? Нужно будет думать, откуда их брать
         * Нет. Если что, то их можно взять из `Sys.argv`
     * Нужна ли поддержка special parameters?
         * Нет
   * Expansions
     * Brace expansion
     * Нужно ли поддерживать Tilde expansion? *не надо*
     * [Shell Parameter Expansion](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)
       * \${parameter}, \$parameter надо
       * \${parameter:offset} и \${parameter:offset:length} надо
       * \${#parameter} надо
       * \${parameter#word} и \${parameter##word} надо
       * \${parameter%word} и
         \${parameter%%word} надо
       * \${parameter/pattern/string}, \${parameter//pattern/string}, \${parameter/#pattern/string}, \${parameter/%pattern/string} и остальное не нужно
     * Двойные backtickи надо
     * Arithmetic Expansion, без него какой-нибудь факториал не написать
     * Process Substitution не надо
     * Word Splitting сделайте дефолтный. Вообще, всякие переменные можно брать из окружения, в котором запушен интерпретатор BashML
     * Filename Expansion не надо
     * [Quote Removal](https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html)
   * Pattern Matching
      * [Рекурсивный](https://stackoverflow.com/questions/28176590) `**` не нужен
      * Нужно ли поддерживать особые случаи в [...]? *я не знаю что это такое*
        * Можно ли при - использовать лишь стандартную "C локаль"? *Да, только стандартную*
        * Нужно ли поддерживать [:class:], [=c=], [.symbol.]? *я не знаю что это, скорее всего нет*
      * [Composite patterns](https://davitenio.wordpress.com/2008/09/14/bash-extended-pattern-matching/) не нужно
   * Перенаправления
      * <, >, >>
      * Custom descriptors *не нужно*
        * Если да, то нужно ли поддерживать дублирования и перемещения дескрипторов?
        * Если да, то нужно ли поддерживать замену кастомных дескрипторов переменными?
      *  разницу между > и >| не нужно
      * Нужно ли поддерживать >& или &>? По мануалу, последнее предпочтительнее, но первое принадлежит к более широкому классу "дублирований", о которых выше
        * `&>word` не надо, но `>word 2>&1` хочу, чтобы работало
      * Here Documents и Here Strings *нет*
      * Нужно ли поддерживать `<>`? *нет*
   * `#!` не надо
   * Массивы нужно, потому что других структур данных там вроде бы нет
      * Индексирование с конца не надо
      * Ассоциативные надо, инициализацию сделайте какую-нить одну из двух видов
        * name=(key1 value1 key2 value2 ... )
        * name=( [key1]=value1 [key2]=value2 ...)
   </details>
1. [Cypher](https://neo4j.com/developer/cypher)
   * мини-язык для доступа к графовым базам данных
   * простой парсер, простой интепретатор, который исполняет запросоы на конкретных графах
   * оптимизации запросов я пока не придумывал, но я думаю, что их придумать не сложно
1. BQN -- упоротый язык с парадигмой array programming (скорее всего на двоих)
   <details><summary>Подробнее</summary>
   * [https://github.com/mlochbaum/BQN/tree/master/tutorial](tutorial)
   * Отличный вариант, чтобы закрепить знания Юникода
   </details>
1.
1. miniKanren -- относительно простой язык реляционного (логического) программирования. Может быть в разных синтаксисах, проще всего найти описание в синтаксисе Scheme в книжке [Reasoned Schemer](http://incf19.com/yynotes/lispbooks/The-Reasoned-Schemer.pdf) (ещё есть стартовый [туториал](https://io.livecode.ch/learn/webyrd/webmk)). Состоит из довольно малого количества понятий.
   <details><summary>Подробнее</summary>
   Ниже кратко опишу в синтаксисе Scheme.
    * Логические переменные, им можно сопоставлять выражение с логическими переменными (или без) внутри и получать **подстановку**.
    * Goal (цель) -- то, что можно посчитать. По сути функция из стартовой подстановки в ленивую последовательность подстановок.
    * Примитив `(run number (vars) goal)` -- вычисляет goal, подставляя туда стартовую пустую подстановку; и  достает из результирующих подстановок (нужны первые `number` штук) посчитанные значения переменных верхнеуровневых `vars`
    * Унификация `(== expr expr)` -- позволяет получать знания о подстановках переменных.
    * Объявление новых логических переменных `fresh (vars) goal` для их использования. Например:

      ```
      > (run 1 (q) (fresh (x y z) (== x z) (== 3 y)))
      (_.0)
      ```
      Выдан один ответ, переменная `q` с номером 0 является свободной, потому что с ней никто не унифицировался

      ```
      > (run 1 (y)  (fresh (x z)   (== x z)    (== 3 y)))
      (3)
      ```
      Мы проунифицировали `y` и  3, что и видно в ответе.
    * Конъюнкция: если пишем `fresh (...) goal1 goal2 ...` то все цели неявно объединяются конъюнкцией. Конъюнкция `(conj l r)` является целью и вычисляется следующим образом:
        * Запускаемся на какой-то подстановке. Левая часть дает какой-то ответ (подстановку), и её и будем передавать в правый goal `r`. Там получатся какие-то ответы, их складываем в ответ. Затем делаем то же самое со вторым ответом из `l` и т.д. От перемены мест конъюнктов ответы не меняются, но может нарушиться завершаемость вычисления этих ответов!
    * delay (пауза) -- указание, что сейчас можно поиск в этой ветке приостановить и поискать в другой. Обычно вставляется внутрь конъюнкции и после fresh.
    * Дизъюнкция: `(conde (goal1 goal2 ...))` -- альтернатива, пытаемся искать ответ разными способами. Если вычисляем `goal` до конца -- будет поиск в глубину (плох тем, что если в одной ветке никогда не найдется ответ -- мы можем там зависнуть). Если делаем по одному шагу в каждом goal --- поиск в ширину (плох тем, что пространство поиска растёт очень быстро). В miniKanren принято делать interleaving search: вычисляем первый дизъюнкт до паузы, затему второй, 1й, 3й, 1й, 2й и т.д. Грубо говоря, первый работает в половине случаев, второй -- в четверти и т.д. Таким образом получается что-то среднее между в глубину и в ширину.
    * TODO: описать disequality constrains.
    </details>

1. C# c исключениями.
    * Стандартные конструкции языка.
    * Целые числа, строки, стандартные функции работы с ними.
    * Массивы и лямбды не надо.
    * try/catch/finally
    * Исключения
        + Пользователь может наследоваться от класса Exception и объявлять свои исключения без новых методов внутри. Получатся какие-то супер-сокращенные объекты с иерархией наследования высоты 2 и синтаксисом [на подобие record'ов](https://diary-of-programmer.blogspot.com/2020/11/finally-c-9-record-equivalent-of-scalas.html). Короче, полноценные объекты не надо.

              public class Person : Exception {
                public string FirstName {get; init;}
                public string LastName {get; init;}
              }
              var a = new Person { FirstName = "Michael", LastName = "Page" };
        + Исключения должны уметь выдавать backtrace c именами функий и позциями в файле, где они вызывались. С этим скорее всего придется запариться
        + Фильтры исключений, которые я просил в том году у Мирошникова -- не надо.
    * Какой-нибудь тайпчекер на случай, чтобы отфильтровывать бредовые программы
    * Какое-нибудь API для чтения/записи файлов, чтобы можно было содержательно протестировать finally
3. Promela

1. [Menhir](http://gallium.inria.fr/~fpottier/menhir/manual.pdf) как LALR интерпретатор<details open><summary>Подробнее</summary>
    * Menhir как LALR интерпретатор принимает последовательность лексем, и грамматикой разбирает их успешно или нет.
    * Надо сделать интерпретатор LALR-парсера по аналогии с менхировским (глава 8 в мануале)
    * **TODO** спросить у Семёна сгодится ли тут простой табличный анализатор
    </details>
1. Make <details><summary>Подробнее</summary>
   * Поддержать объявление и вызов функций make (скорее всего [вот этот пример](https://github.com/Kakadu/ocanren-perf/blob/master/Makefile) достаточно полный)
   * Так как язык Makefileов выглядит достаточно просто, то надо еще реализовать клон make, который можно использовать как билд-систему. Протестировать сборку C и OCaml проектов клоном make
   </details>
1. Solidity (Шишкин)
   - Стандартные типы и операции над ними (uint, bool, string, mapping, array)
   - Функции (рекурсия)
   - Модификаторы доступа (public, private)
   - Переменные и константы
   - require (возвращает ошибку и откатывает все изменения)
   - if, for
   - Интерактор позволяющий:
      1. Вызывать public функции
      1. Обращаться к public членам
      1.  Изменять public члены

   <details><summary>Пример контракта</summary>

   ```Solidity
   contract Example {

      uint public value = 0;
      function storeValue(uint x) public {
         value = x;
         require(value < 100, "Huge value");
      }

      mapping(uint => uint) private cache;
      function privateFib(uint arg) private returns (uint) {
         if (arg == 0 || arg == 1) {
            return 1;
         }
         uint current = cache[arg];
         if (current == 0){
            uint result = privateFib(arg - 1) + privateFib(arg - 2);
            cache[arg] = result;
            return result;
         }
         else {
            return current;
         }
      }

      function fib(uint arg) public returns (uint) {
         return privateFib(arg);
      }

      uint public constant arrSize = 10;
      string[arrSize] private arr;

      function storeInArr(uint start, uint stop, string calldata newValue) public {
         for (uint i = start; i < stop; i++) {
            require(i < arrSize, "Incorrect stop");
            arr[i] = newValue;
         }
      }

      function readFromArr(uint index) public returns (string memory) {
         require(index < arrSize);
         return arr[index];
      }

   }
   ```
   </details>

   <details><summary>Пример взаимодействия</summary>

   ```
   ~> myAwesomeSolidityInterpreter Example.sol
   Example.sol successfully uploaded!
   Available functions:
      storeValue(uint)
      loadValue() returns (uint)
      fib(uint) returns (uint)
      storeInArr(uint, uint, string)
      readFromArr(uint) returns (string)
   Available members:
      value
      arrSize

   > storeValue(10)
   ()
   > value
   10
   > storeValue(101)
   Reverted with: Huge value
   > value
   10
   > fib(2)
   2
   > privateFib(2)
   Reverted with: access denied
   > unknownFunction()
   Reverted with: unknown function
   > unknownMember = 3
   Reverted with: unknown member
   > storeInArr(0, 3, "Haskell > OCaml")
   ()
   > readFromArr(0)
   Haskell > OCaml
   > storeInArr(0, 12, "Haskell < OCaml")
   Reverted with: Incorrect stop
   > readFromArr(0)
   Haskell > OCaml
   > <Ctrl+D>
   Bye-bye!
   ~>
   ```
   </details>

##### Гробы, которые никто не возьмет

1. Java и generics (2 человека) <details><summary>Подробнее</summary>
   * целые числа (`float` не нужно)
   * рекурсия
   * стандартные конструкции языка
     * `if`, `else`, `while` (взаимозаменяем с `do { ... } while`), `for`
     * `break` и `continue` оставить на потом
     * `switch` можно не реализовывать
     * исключения и тернарный оператор не нужны
   * присваивание
   * анонимные функции
   * классы (без `enum`), интерфейсы, наследование
   * поддержка многопоточности, нативного кода и сериализации не нужна
   * многофайловость не требуется
   * передача аргументов командной строки в `main` не нужна
   * в каком-то виде понадобится поддержка функций стандартной библиотеки
   * из методов класса `Object` достаточно поддерживать `hashCode`, `equals` и `toString`
   * реализовать более точное указание generic параметров (например, `? super x` и т.п.)
      * если заработает проверка типов (нужно отдельно реализовать тайпчекер) и интерпретатор на вот такой программе, то будет круто
    ```java
    interface Z {}
    interface N<x> {}
    interface L<x> {}
    interface Qlr<x> {}
    interface Qrl<x> {}
    interface E<x> extends
       Qlr<N< ? super Qr< ? super E< ? super E<?super x>>>>>,
       Qrl<N< ?super Ql< ?super E< ?super E<?super x>>>>> {}
    interface Ql<x> extends
       L<N<?super Ql<?super L<?super N<?super x>>>>>,
       E<Qlr<?super N<?super x>>> {}
    interface Qr<x> extends
       L<N<?super Qr<?super L<?super N<?super x>>>>>,
       E<Qrl<?super N<?super x>>> {}
    class Main {
       L<?super N<?super
       L<?super N<?super
       L<?super N<?super
       E<?super E<?super Z>>>>>>>>
        doit( Qr<? super E<? super E<? super Z>>> v ) {
         return v;
       }
    }
    ```
    </details>
1.
1. OCaml + implicits
   * В OCaml нет ad hoc полиморфизма (то, что вы знаете под термином overloading), поэтому многим хочется иметь в грядущей версии OCaml следующую штуку
      * в области видимости объявляется некоторое количество OCamlовских модулей
      * у функций могут появляться неявные аргументы (implicit), которые программист не передает явно руками
      * момент вызова функции компилятор ищет в области видимости подходящие по типу модули и подставляет и вместо неявных аргументов, если не найти -- ошибка, если больше 1го подходящего варианта -- тоже
1. Scala 3 + givens
   * как предыдущее, только вместо OCaml -- синтаксис Scala 3, вместо камлёвых модулей -- скальные объекты
1. мини-Coq с индуктивными типами (2 человека)
   * похож на OCaml + ADT, но с некоторыми ограничениями
   * вводятся ограничения на объявления алгебраических  типов
      * чтобы избегать [парадокса Карри](https://counterexamples.org/currys-paradox.html)
      * иметь индуктивные типы, размер которых очевиден
   * объявляемые функции принимаются только если они завершаются
      * проверка делается на основе рассуждения "убывает по такому-то аргументу"
1.

##### Определюсь/допишу потом если тем будет не хватать/или кому-то очень захочется/и не будет лениво их доформулировать, а может на 2023 год оставлю

1. Haskell typechecker + undecidable instances.
1. Nemerle http://nemerle.org/About
1. Purescript
1. Fortran?
1. Visual Basic.NET (клон C# с другим синтаксисом)
    * [На вики есть](https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Visual_Basic_.NET#Features_of_Visual_Basic_.NET_not_found_in_C#) список отличий. Если сесть и посмотреть, то наверняка можно придумать задачу.
1. C# c паттерн-мэтчингом
1. Какие-нибудь смарт-контракты
1. MSIL
1. OCaml с первоклассными модулями
1.
1. BibTex (описание, примеры и способы улучшения рассказал [Guy Steel](https://www.youtube.com/watch?v=OhZQabtOMdI))
1. Aspectual Caml?
1. Aspect C# ?
1. C# c [Goto](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/goto) и ещё чем-нибудь
1. Scala где есть и аргументы call-by-value, и аргументы call-by-name. И ещё что-нибудь
1. Refinement types by [Ranjit Jhala](https://github.com/ranjitjhala/sprite-lang)
1. Sed (а тестировать будем примером реализации [brainfuck на sed](https://github.com/stedolan/bf.sed))
1. [Gcaml](http://www.yl.is.s.u-tokyo.ac.jp/~furuse/gcaml/index.html)
1. Smalltalk
2. Ideal Parallel Algol
3. AWK
4. J
5. TSQL
6. Forth (может оказаться слишком простым)
9. Amulet? [https://github.com/amuletml/amulet](https://github.com/amuletml/amulet)
10. Prolog/Datalog [Solving murder with prolog](https://xmonader.github.io/prolog/2018/12/21/solving-murder-prolog.html)
11. TCL
12. Полиморфные варианты set-theoretic (с общим парсером и интерпретатором)
13. Язык с присваиванием через монаду IO
14. ML + subtyping по Долану
15. GADT одним способом типизации
16. И другим способом типизации
17. Функции с исключениями + yeild
18. Scheme + typed racket
19. ФП c letbox от Трунова [https://github.com/mtt-lang/mtt-lang/tree/master/examples](https://github.com/mtt-lang/mtt-lang/tree/master/examples)
20. [Новый](https://pharo.org) Smalltalk с идеей сделать там resumable exceptions, которые как эффекты (**ГРОБ**)
21. Wolfram Mathematica (там синтаксис [очень стрёмный](https://22century.ru/popular-science-publications/wolfram-mathematica))
22. Erlang [на основе карамели](https://discuss.ocaml.org/t/ann-erlang-0-0-14-a-toolkit-to-manipulate-erlang-sources/)
23. Curry/Mercury?
24. [Jsonet](https://jsonnet.org/ref/language.html) -- template language
25. Copattern maching по моему докладу


В общем и целом вы делаете парсер, интерпретатор + преобразования AST, набираете баллы. Они влияют на максимум оценки за экзамен. Планируется, что те, кто сделают интерпретатор смогут претендовать на оценку C, а также смогут легко добрать баллов до A.

Задачи не вполне равнозначные по сложности. В ближайшем будущем я планирую их побалансировать и давать за некоторые больше баллов. Точная разбалловка будет позже

-->

##### Прочие замечания

Тема "на двоих" означает, что делаете в двоем, вместе, одно и то же. В конце я буду ожидать, что оба разбираются в коде и смогут объяснить, что там происходит. Не сможете продемонстрировать, что знаете код напарника как свой --- пинайте на себя

Если у Вас есть предложения по добавлению других языков -- пишите.
